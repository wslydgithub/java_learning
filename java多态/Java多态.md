# Java多态

## 方法重写

即子类和父类具有同名方法

这里的同名方法不仅是包括方法名相同，还包括返回类型，参数列表也要相同，但是方法修饰范文可以扩大或者相同`public>protocted>default`

方法重写对于父类的`private`方法是没有效果的，因为`private`方法仅适用于该类，其不能被继承，且在其他类中不可见。

### 运行时多态

`后期绑定`：指的是被调用的方法在编译期间不能确定下来，只能在运行期间根据实际的绑定来运行，称为后期绑定。

`运行时多态`：其实就是方法重写

***方法重载叫做编译时多态，属于前期绑定，方法重写叫做运行时多态，属于后期绑定***

```java
public class Test
{
    public  static  void main(String[] args){
        Animal an =new Cat();
        an.eat();
    }
}
// 输出:cat eat
```

***如何看待在向上转型，方法重写后，还是调用的子类的方法：***

我是从内存角度理解的，虽然我们这里是按照`Animal`类来进行编译的，但是从地址上来看，我们的地址存放的仍然是`Cat`类型的地址，而`Java`中所有的传递都是值传递，这里传递的是地址，所以本质上还是`Cat`类型，所以方法还是`Cat`类型的方法。

所以判断的时候只用判断`new`关键字后面的类型是什么，调用的就是哪一个类型的方法。

### 子类和父类由static修饰的方法

`static`修饰的方法是静态方法，修饰的变量是静态变量，相当于属于一个类，不随其所生成的实例而改变，可以被所用的对象使用，通过类名调用

使用`private,static,final`修饰的方法和变量属于早期绑定，所以不是方法重写

调用的时候调用的是父类的

### 解耦合

`动态绑定`:在运行时根据对象的类型进行绑定，也就是后期绑定。

`解耦合`：解耦合解除耦合关系，降低对象之间的依赖性。

### 同名变量的继承

在`java`的父子关系中，同名变量不进行继承。这种变量是相互独立的

### 方法重载和方法重写

| 名称       | 方法重载 | 方法重写       |
| ---------- | -------- | -------------- |
| 类         | 一个类   | 继承关系       |
| 方法名     | 相同     | 相同           |
| 方法参数   | 可以不同 | 相同           |
| 返回值类型 | 可以不同 | 相同           |
| 调用方法   | 参数决定 | 创建的对象决定 |
| static     | 是       | 不是           |

